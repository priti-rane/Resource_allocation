# -*- coding: utf-8 -*-
"""PP-16-14-TASK _2_RESOURCE _ALLOCATION_PRITI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tEETYfs_HCKRLVbHV8wCyMZQ1nm5Cjdu

##Task: 2

*   Name : Rahatun Nesa Priti

*   ID: PP-16-14

##Title: Resource Management for Construction Projects
Objective Create a simple Python program to track the allocation and usage of resources in construction projects. The goal is to ensure materials, labor, and equipment are used effectively, and identify any inefficiencies.

##1.Data Import


*   Load resource usage data from a CSV file.
*  Ensure that all required fields are present.
"""

import csv

# Define the headers
headers = ['ID', 'Project_ID', 'Task_ID', 'Resource_Type', 'Resource_Name', 'Amount_Required', 'Amount_Used', 'Start_Date', 'End_Date']

# Specify the file name
filename = 'resource_for_construction.csv'

# Create and write the headers to the CSV file
with open(filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(headers)

print(f"CSV file '{filename}' created with headers only.")

import csv
import pandas as pd

# Define the headers
headers = ['ID', 'Project_ID', 'Task_ID', 'Resource_Type', 'Resource_Name', 'Amount_Required', 'Amount_Used', 'Start_Date', 'End_Date']

# Specify the file name
filename = 'resource_for_construction.csv'

# Specify the path to your dataset file
dataset_filepath = '/content/drive/MyDrive/Colab Notebooks/Rahatun_Nisa_Resource_Management_for_Construction_Projects.csv'  # Replace with your actual file path

# Read data from the dataset file using pandas
dataset_data = pd.read_csv(dataset_filepath)

# Append data to the CSV file
with open(filename, 'a', newline='') as csvfile:  # Open in append mode ('a')
    writer = csv.writer(csvfile)
    # Iterate through the DataFrame rows and write them to the CSV
    for index, row in dataset_data.iterrows():
        writer.writerow(row.tolist())  # Convert each row to a list before writing

print(f"Data from '{dataset_filepath}' appended to '{filename}'.")

import pandas as pd

# Specify the file name
filename = 'resource_for_construction.csv'

# Read the CSV file into a pandas DataFrame
resource_data = pd.read_csv(filename)

# Display the DataFrame
resource_data

"""###Clean dataset :

"""

import pandas as pd

# Specify the file name
filename = 'resource_for_construction.csv'

# Read the CSV file into a pandas DataFrame
resource_data = pd.read_csv(filename)

# 1. Handling Missing Values:

# Check for missing values
print("Missing values before cleaning:")
print(resource_data.isnull().sum())

# Option 1: Remove rows with any missing values (if appropriate)
# resource_data.dropna(inplace=True)

# Option 2: Fill missing values with appropriate values (e.g., 0 for numeric, 'Unknown' for categorical)
resource_data['Amount_Used'].fillna(0, inplace=True)  # Fill Amount_Used with 0
resource_data['Start_Date'].fillna('Unknown', inplace=True)  # Fill Start_Date with 'Unknown'
resource_data['End_Date'].fillna('Unknown', inplace=True)  # Fill End_Date with 'Unknown'


# 2. Handling Inconsistent Data Types:

# Check data types of columns
print("\nData types before cleaning:")
print(resource_data.dtypes)

# Convert 'Start_Date' and 'End_Date' to datetime objects (if needed)
resource_data['Start_Date'] = pd.to_datetime(resource_data['Start_Date'], errors='coerce')
resource_data['End_Date'] = pd.to_datetime(resource_data['End_Date'], errors='coerce')

# 3. Handling Duplicates:

# Check for and remove duplicate rows
print("\nNumber of duplicate rows:", resource_data.duplicated().sum())
resource_data.drop_duplicates(inplace=True)

# 4. Handling Outliers (if needed):
# (This step depends on the specific data and your domain knowledge)
# Example: Removing outliers in 'Amount_Used' using the IQR method
# Q1 = resource_data['Amount_Used'].quantile(0.25)
# Q3 = resource_data['Amount_Used'].quantile(0.75)
# IQR = Q3 - Q1
# lower_bound = Q1 - 1.5 * IQR
# upper_bound = Q3 + 1.5 * IQR
# resource_data = resource_data[(resource_data['Amount_Used'] >= lower_bound) & (resource_data['Amount_Used'] <= upper_bound)]


# Display the cleaned DataFrame
print("\nCleaned DataFrame:")
resource_data

"""##2.Resource Tracking


*   Track material usage (e.g., concrete, bricks) and labor hours across tasks.
*   Ensure that resources are available for each task.





"""

def track_resources(task_id, resource_type, amount_needed):
    """Tracks material usage and labor hours for a task.

    Args:
        task_id: The ID of the task.
        resource_type: The type of resource (e.g., 'concrete', 'labor').
        amount_needed: The amount of the resource needed for the task.

    Returns:
        True if the resource is available, False otherwise.
    """

    # Filter data for the specific task and resource type
    task_resource_data = resource_data[
        (resource_data['Task_ID'] == task_id) &
        (resource_data['Resource_Type'] == resource_type)
    ]

    # Calculate total amount of resource used for the task
    total_used = task_resource_data['Amount_Used'].sum()

    # Check if enough resource is available
    if total_used + amount_needed <= task_resource_data['Amount_Required'].sum():
        print(f"Enough {resource_type} is available for Task {task_id}.")

        # Update the 'Amount_Used' column in the DataFrame to reflect resource usage
        # (Important for real-world applications)
        resource_data.loc[
            (resource_data['Task_ID'] == task_id) & (resource_data['Resource_Type'] == resource_type),
            'Amount_Used'
        ] += amount_needed

        return True
    else:
        print(f"Insufficient {resource_type} for Task {task_id}.")
        return False

# Example usage 1: Track concrete for Task 1
track_resources(1, 'concrete', 50)

# Example usage 2: Track labor for Task 2
track_resources(2, 'labor', 100)

# Display the updated resource_data DataFrame (optional)
print("\nUpdated resource_data DataFrame:")
print(resource_data)

"""##3.Resource Efficiency


*   Calculate how much material is used per task and identify if any resource is overused or underused.




"""

# Calculate material usage per task
material_usage_per_task = resource_data.groupby(['Task_ID', 'Resource_Type'])[['Amount_Used', 'Amount_Required']].sum().reset_index()

# Identify overused and underused resources
material_usage_per_task['Overused'] = material_usage_per_task['Amount_Used'] > material_usage_per_task['Amount_Required']
material_usage_per_task['Underused'] = material_usage_per_task['Amount_Used'] < material_usage_per_task['Amount_Required']

# Display the results
print(material_usage_per_task)

"""##4.Resource Availability Check


*   Check if there is enough resource for the upcoming tasks.




"""

import pandas as pd

# Assuming 'resource_data' is your cleaned DataFrame and 'Start_Date' indicates upcoming tasks

# Filter for upcoming tasks (assuming today's date for simplicity)
upcoming_tasks = resource_data[resource_data['Start_Date'] > pd.Timestamp.today()]

# Group by resource type and sum required and used amounts
resource_check = upcoming_tasks.groupby('Resource_Type')[['Amount_Required', 'Amount_Used']].sum()

# Calculate available resources (total - used)
resource_check['Available_Resources'] = resource_check['Amount_Required'] - resource_check['Amount_Used']

# Check if enough resources are available
resource_check['Enough_Resources'] = resource_check['Available_Resources'] >= 0

# Display the results
print(resource_check)

"""Insight:The 'Enough_Resources' column is now set to True if 'Available_Resources' is greater than or equal to 0, indicating that there are enough resources available (or potentially a surplus). It is set to False if 'Available_Resources' is negative, indicating a shortage.

##5.Visualization

*   Create bar charts to compare resource usage across tasks.
"""

!pip install matplotlib

import matplotlib.pyplot as plt
import pandas as pd

# Assuming 'resource_data' is your cleaned DataFrame

# Group data by task and resource type, summing the amount used
task_resource_usage = resource_data.groupby(['Task_ID', 'Resource_Type'])['Amount_Used'].sum().unstack()

# Create the bar chart
task_resource_usage.plot(kind='bar', stacked=True, figsize=(10, 6))

# Customize the chart
plt.title('Resource Usage Across Tasks')
plt.xlabel('Task ID')
plt.ylabel('Amount Used')
plt.legend(title='Resource Type')
plt.xticks(rotation=0)  # Keep x-axis labels horizontal

# Display the chart
plt.show()

!pip install matplotlib

import matplotlib.pyplot as plt
import pandas as pd

# Assuming 'resource_data' is your cleaned DataFrame

# Function to create a bar chart for a specific resource type
def create_resource_chart(resource_type):
    # Filter data for the specific resource type
    filtered_data = resource_data[resource_data['Resource_Type'] == resource_type]

    # Group by resource name and sum amount used
    resource_usage = filtered_data.groupby('Resource_Name')['Amount_Used'].sum().reset_index()

    # Calculate percentage usage
    total_usage = resource_usage['Amount_Used'].sum()
    resource_usage['Percentage'] = (resource_usage['Amount_Used'] / total_usage) * 100

    # Create bar chart
    plt.figure(figsize=(8, 6))  # Adjust figure size as needed
    plt.bar(resource_usage['Resource_Name'], resource_usage['Amount_Used'])
    plt.title(f'Resource Usage for {resource_type}')
    plt.xlabel('Resource Name')
    plt.ylabel('Amount Used')
    plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability

    # Add percentage labels on top of bars
    for i, v in enumerate(resource_usage['Amount_Used']):
        plt.text(i, v, f"{resource_usage['Percentage'][i]:.1f}%", ha='center', va='bottom')

    plt.tight_layout()  # Adjust layout for better spacing
    plt.show()

# Create charts for different resource types
resource_types = resource_data['Resource_Type'].unique()  # Get unique resource types
for resource_type in resource_types:
    create_resource_chart(resource_type)

!pip install matplotlib

import matplotlib.pyplot as plt
import pandas as pd

# Assuming 'resource_data' is your cleaned DataFrame

# Function to create a pie chart for a specific resource type
def create_resource_chart(resource_type):
    # Filter data for the specific resource type
    filtered_data = resource_data[resource_data['Resource_Type'] == resource_type]

    # Group by resource name and sum amount used
    resource_usage = filtered_data.groupby('Resource_Name')['Amount_Used'].sum().reset_index()

    # Calculate percentage usage
    total_usage = resource_usage['Amount_Used'].sum()
    resource_usage['Percentage'] = (resource_usage['Amount_Used'] / total_usage) * 100

    # Create pie chart
    plt.figure(figsize=(8, 6))  # Adjust figure size as needed
    plt.pie(resource_usage['Amount_Used'], labels=resource_usage['Resource_Name'], autopct='%1.1f%%', startangle=90)
    plt.title(f'Resource Usage for {resource_type}')
    plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

    plt.tight_layout()  # Adjust layout for better spacing
    plt.show()

# Create charts for different resource types
resource_types = resource_data['Resource_Type'].unique()  # Get unique resource types
for resource_type in resource_types:
    create_resource_chart(resource_type)

!pip install matplotlib

import matplotlib.pyplot as plt
import pandas as pd

# Assuming 'resource_data' is your cleaned DataFrame

# Choose the columns for the x and y axes
x_column = 'Amount_Required'  # Replace with your desired x-axis column
y_column = 'Amount_Used'     # Replace with your desired y-axis column

# Create the scatter plot
plt.figure(figsize=(8, 6))  # Adjust figure size as needed
plt.scatter(resource_data[x_column], resource_data[y_column])

# Customize the plot
plt.title('Scatter Plot of Resource Usage')
plt.xlabel(x_column)
plt.ylabel(y_column)

# Display the plot
plt.show()